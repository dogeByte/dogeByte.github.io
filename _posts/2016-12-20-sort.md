---
layout: post
title:  "常见的排序算法"
date:   2016-12-20 12:58:19
categories: Java
tags: Java
---

# 目录
1. [选择排序](#1)
2. [冒泡排序](#2)
3. [快速排序](#3)
4. [复杂度和稳定性](#4)

将不同的排序算法封装并继承共同的抽象类 `Sorter`，使它们可以相互替换：

```java
public abstract class Sorter<T> {

    private Comparator<? super T> comparator;
    protected Sorter() {}
    protected Sorter(Comparator<? super T> comparator) {
        this.comparator = comparator;
    }

    public abstract void sort(T[] array);

    protected int compare(T t1, T t2) {
        if (comparator != null) {
            return comparator.compare(t1, t2);
        }
        return ((Comparable<? super T>) t1).compareTo(t2);
    }

    protected void swap(T[] array, int i, int j) {
        if (i != j) {
            T temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
}
```

<h1 id="1">选择排序</h1>

```java
public class SelectionSorter<T> extends Sorter<T> {

    public SelectionSorter() {}
    public SelectionSorter(Comparator<? super T> comparator) {
        super(comparator);
    }

    @Override
    public void sort(T[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int max = array.length - i - 1;
            for (int j = 0; j < array.length - i - 1; j++) {
                if (this.compare(array[j], array[max]) > 0) {
                    max = j;
                }
            }
            swap(array, max, array.length - i - 1);
        }
    }
}
```

<h1 id="2">冒泡排序</h1>

```java
public class BubbleSorter<T> extends Sorter<T> {

    public BubbleSorter() {}
    public BubbleSorter(Comparator<? super T> comparator) {
        super(comparator);
    }

    @Override
    public void sort(T[] array) {
        boolean finished = false;
        for (int i = 0; i < array.length - 1 && !finished; i++) {
            finished = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                if (compare(array[j], array[j + 1]) > 0) {
                    swap(array, j, j + 1);
                    finished = false;
                }
            }
        }
    }
}
```

<h1 id="3">快速排序</h1>

快速排序可以分为三步：

1. 在数据集之中，选择一个元素作为枢轴（pivot）元素。
2. 分区（partition）：将所有小于枢轴的元素，都移到枢轴的左边；将所有大于枢轴的元素，都移到枢轴的右边。分区操作后，枢轴元素所处的位置就是最终排序后它所在的位置。
3. 对枢轴元素左右两侧的两个子集，分别重复第一步和第二步（递归），直到所有子集都只剩下一个元素为止。

![快速排序](https://s25.postimg.org/iyzrivm9b/quick_sort.gif)

分区（partition）是快速排序的主要内容，步骤如下：

1. 把枢轴元素移到末尾（如果直接选择最后一个元素作为枢轴元素，则不需要移动）。
2. 从左到右（除了最后的枢轴元素），将小于等于枢轴的元素依次移动到数组的开头，每次移动后将 index 加 1，表示下一个小于等于枢轴的元素将要移动到的位置。
3. 循环结束后 index 所代表的位置就是最终排序后枢轴元素所在的位置，所以将枢轴元素（末尾）与 index 处的元素交换。

```java
public class QuickSorter<T> extends Sorter<T> {

    public QuickSorter() {}
    public QuickSorter(Comparator<? super T> comparator) {
        super(comparator);
    }

    @Override
    public void sort(T[] array) {
        this.sort(array, 0, array.length - 1);
    }

    private void sort(T[] array, int head, int tail) {
        if (head < tail) {
            int index = this.partition(array, head, tail);
            sort(array, head, index - 1);
            sort(array, index + 1, tail);
        }
    }

    private int partition(T[] array, int head, int tail) {
        int index = head;
        T pivot = array[tail];  // 选取最后一个元素作为枢轴元素
        for (int i = head; i < tail; i++) {
            if (compare(array[i], pivot) <= 0) {
                swap(array, i, index++);
            }
        }
        swap(array, tail, index);
        return index;           // 枢轴元素的索引值
    }
}
```

分区的另一种实现方式如下，思路和上面的一样，但代码逻辑不如上面的清晰：

```java
private int partition(T[] array, int head, int tail) {
    T pivot = array[head];
    while (head < tail) {
        while (head < tail && this.compare(pivot, array[tail]) <= 0) {
            tail--;
        }
        if (head < tail) {
            array[head++] = array[tail];
        }
        while (head < tail && this.compare(pivot, array[head]) >= 0) {
            head++;
        }
        if (head < tail) {
            array[tail--] = array[head];
        }
    }
    array[head] = pivot;
    return head;
}
```

<h1 id="4">复杂度和稳定性</h1>

<table border="1" width="100%">
<tr align="center">
<td rowspan="2">排序算法</td>
<td colspan="3">时间复杂度</td>
<td rowspan="2">空间复杂度</td>
<td rowspan="2">稳定性</td>
<td rowspan="2">复杂性</td>
</tr>
<tr align="center">
<td>平均</td>
<td>最好</td>
<td>最坏</td>
</tr>
<tr align="center">
<td>插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr align="center">
<td>希尔排序</td>
<td>O(n<sup>1.3</sup>)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>O(1)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr align="center">
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr align="center">
<td>快速排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr align="center">
<td>选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr align="center">
<td>堆排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr align="center">
<td>归并排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>复杂</td>
</tr>
<tr align="center">
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(r)</td>
<td>稳定</td>
<td>复杂</td>
</tr>
</table> 